<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Karaoguelike</title>
  <style>
    :root { --pad: 14px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; background:#0b0c10; color:#f4f4f6; }
    header { padding: 18px var(--pad); border-bottom: 1px solid rgba(255,255,255,.08); display:flex; gap:12px; align-items:center; justify-content:space-between; }
    h1 { font-size: 16px; margin: 0; font-weight: 650; letter-spacing: .2px; }
    .wrap { padding: var(--pad); max-width: 1100px; margin: 0 auto; }
    .card { background: rgba(255,255,255,.04); border: 1px solid rgba(255,255,255,.08); border-radius: 14px; padding: 14px; }
    .grid { display:grid; grid-template-columns: 360px 1fr; gap: 14px; }
    @media (max-width: 900px){ .grid { grid-template-columns: 1fr; } }

    .btn { background:#fff; color:#000; border:0; padding: 10px 12px; border-radius: 12px; font-weight: 650; cursor:pointer; }
    .btn.secondary { background: rgba(255,255,255,.10); color:#fff; border: 1px solid rgba(255,255,255,.14); }
    .btn:disabled { opacity: .55; cursor:not-allowed; }

    .row { display:flex; gap: 10px; flex-wrap: wrap; align-items:center; }
    .muted { color: rgba(255,255,255,.70); font-size: 12px; line-height: 1.4; }
    .tiny { color: rgba(255,255,255,.55); font-size: 11px; }

    .decklist { display:flex; flex-direction:column; gap: 10px; margin-top: 10px; }
    label.deck { display:flex; justify-content:space-between; gap: 10px; align-items:center; padding: 10px 10px; border-radius: 12px; border: 1px solid rgba(255,255,255,.10); background: rgba(255,255,255,.03); }
    label.deck input { transform: scale(1.1); }
    .pill { font-size: 11px; padding: 3px 8px; border-radius: 999px; border: 1px solid rgba(255,255,255,.14); color: rgba(255,255,255,.85); }

    .results { display:flex; flex-direction:column; gap: 12px; }
    .resultTitle { display:flex; align-items:center; justify-content:space-between; gap: 10px; }
    .resultTitle strong { font-size: 13px; }
    .drawn { font-size: 20px; font-weight: 750; margin: 6px 0 0 0; letter-spacing: .2px; }
    ul { margin: 8px 0 0 18px; }
    li { margin: 4px 0; }

    .error { color: #ffb3b3; }
    .ok { color: #b7ffcd; }
    .spinner { display:inline-block; width: 14px; height: 14px; border: 2px solid rgba(255,255,255,.25); border-top-color: #fff; border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    code.inline { background: rgba(255,255,255,.08); padding: 1px 6px; border-radius: 8px; }
  </style>
</head>
<body>
  <header>
    <h1>Karaoguelike</h1>
    <div class="row">
      <button class="btn secondary" id="btnReload">Reload data</button>
      <button class="btn" id="btnDraw" disabled>Draw cards</button>
    </div>
  </header>

  <div class="wrap">
    <div class="grid">
      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <div>
            <div class="muted">Data source</div>
            <div class="tiny">Google Sheets → <b>published CSV</b> (no login / no CORS redirect)</div>
          </div>
          <div id="status" class="pill">Not loaded</div>
        </div>

        <div style="margin-top:12px;">
          <div class="muted">Configure</div>
          <div class="tiny" style="margin-top:6px;">
            Update the <code class="inline">CSV_URLS</code> object in the script if your sheet links change.
          </div>
        </div>

        <div style="margin-top:14px;">
          <div class="muted">Decks in play</div>
          <div class="decklist" id="deckList"></div>
        </div>

        <div style="margin-top:14px;" class="row">
          <button class="btn secondary" id="btnSelectAll">Select all</button>
          <button class="btn secondary" id="btnSelectNone">Select none</button>
        </div>

        <div style="margin-top:10px;" class="tiny">
          Tip: turn off “Specific Artist” if you want more open rounds.
        </div>

        <div id="err" class="tiny error" style="margin-top:10px;"></div>
      </div>

      <div class="card">
        <div class="resultTitle">
          <strong>Draw</strong>
          <span class="tiny">Suggestions will appear if found in the matching tab.</span>
        </div>
        <div class="results" id="results" style="margin-top:10px;"></div>
      </div>
    </div>
  </div>

  <script>
    /***********************
     * 1) PUT YOUR PUBLISHED CSV LINKS HERE
     * (these are your links; do not swap to /spreadsheets/d/.../export)
     ***********************/
    const CSV_URLS = {
      "MAIN": "https://docs.google.com/spreadsheets/d/e/2PACX-1vRCJK_-jJKTBYKiYVQz67eXaufFV6z6wxfWY8PFuhPhVp1xOv9dPhJefpJe_RziTvYELRGsHKGRErh6/pub?gid=210868448&single=true&output=csv",
      "Artist Category": "https://docs.google.com/spreadsheets/d/e/2PACX-1vRCJK_-jJKTBYKiYVQz67eXaufFV6z6wxfWY8PFuhPhVp1xOv9dPhJefpJe_RziTvYELRGsHKGRErh6/pub?gid=2134899012&single=true&output=csv",
      "Specific Artist": "https://docs.google.com/spreadsheets/d/e/2PACX-1vRCJK_-jJKTBYKiYVQz67eXaufFV6z6wxfWY8PFuhPhVp1xOv9dPhJefpJe_RziTvYELRGsHKGRErh6/pub?gid=933810467&single=true&output=csv",
      "Era": "https://docs.google.com/spreadsheets/d/e/2PACX-1vRCJK_-jJKTBYKiYVQz67eXaufFV6z6wxfWY8PFuhPhVp1xOv9dPhJefpJe_RziTvYELRGsHKGRErh6/pub?gid=2053657456&single=true&output=csv",
      "Genre": "https://docs.google.com/spreadsheets/d/e/2PACX-1vRCJK_-jJKTBYKiYVQz67eXaufFV6z6wxfWY8PFuhPhVp1xOv9dPhJefpJe_RziTvYELRGsHKGRErh6/pub?gid=308425524&single=true&output=csv",
      "Prompt": "https://docs.google.com/spreadsheets/d/e/2PACX-1vRCJK_-jJKTBYKiYVQz67eXaufFV6z6wxfWY8PFuhPhVp1xOv9dPhJefpJe_RziTvYELRGsHKGRErh6/pub?gid=1185779772&single=true&output=csv",
      "Song Title Rule": "https://docs.google.com/spreadsheets/d/e/2PACX-1vRCJK_-jJKTBYKiYVQz67eXaufFV6z6wxfWY8PFuhPhVp1xOv9dPhJefpJe_RziTvYELRGsHKGRErh6/pub?gid=186500093&single=true&output=csv"
    };

    /***********************
     * 2) HELPERS
     ***********************/
    async function fetchCsv(url) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`Fetch failed (${res.status}). Check that the tab is published as CSV.`);
      return await res.text();
    }

    // Robust CSV parser: handles quoted commas and quoted newlines.
    function parseCSV(text) {
      const rows = [];
      let row = [];
      let cur = "";
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        const next = text[i + 1];

        if (ch === '"' && inQuotes && next === '"') { cur += '"'; i++; continue; }
        if (ch === '"') { inQuotes = !inQuotes; continue; }

        if (ch === ',' && !inQuotes) {
          row.push(cur); cur = "";
          continue;
        }

        if ((ch === '\n' || ch === '\r') && !inQuotes) {
          if (ch === '\r' && next === '\n') i++;
          row.push(cur); cur = "";
          // ignore completely empty trailing line
          if (row.some(cell => (cell ?? "").trim() !== "")) rows.push(row.map(x => (x ?? "").trim()));
          row = [];
          continue;
        }

        cur += ch;
      }

      row.push(cur);
      if (row.some(cell => (cell ?? "").trim() !== "")) rows.push(row.map(x => (x ?? "").trim()));
      return rows;
    }

    function uniq(arr) {
      return [...new Set(arr.filter(Boolean))];
    }

    function sample(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function setStatus(text, ok=true) {
      const el = document.getElementById("status");
      el.textContent = text;
      el.className = "pill" + (ok ? " ok" : "");
    }

    function normalizeKey(s) {
      return (s ?? "").trim();
    }

    function splitSuggestionsCell(s) {
      const raw = (s ?? "").trim();
      if (!raw) return [];
      // split on ; | or line breaks if someone pasted multiple suggestions into one cell
      return raw.split(/[;|]\s*|\r?\n/).map(x => x.trim()).filter(Boolean);
    }

    /***********************
     * 3) APP STATE
     ***********************/
    let decks = {};          // { deckName: [cards...] }
    let suggestions = {};    // { deckName: Map(cardName -> [suggestions...]) }
    let selectedDecks = new Set();

    const DEFAULT_DECK_ORDER = ["Artist Category", "Specific Artist", "Era", "Genre", "Prompt", "Song Title Rule"];

    /***********************
     * 4) LOAD DATA
     ***********************/
    async function loadAll() {
      const errEl = document.getElementById("err");
      errEl.textContent = "";
      setStatus("Loading…", true);
      document.getElementById("btnDraw").disabled = true;
      document.getElementById("deckList").innerHTML = "";
      document.getElementById("results").innerHTML = "";

      try {
        if (!CSV_URLS.MAIN) throw new Error("Missing CSV_URLS.MAIN.");

        // --- Load MAIN ---
        const mainText = await fetchCsv(CSV_URLS.MAIN);
        const mainRows = parseCSV(mainText);
        if (mainRows.length < 2) throw new Error("MAIN tab returned no rows. Is it published correctly?");

        const headers = mainRows[0].map(h => (h ?? "").trim());
        const dataRows = mainRows.slice(1);

        decks = {};
        headers.forEach((h, idx) => {
          if (!h) return;
          const colCards = uniq(dataRows.map(r => (r[idx] || "").trim()).filter(Boolean));
          if (colCards.length) decks[h] = colCards;
        });

        if (!Object.keys(decks).length) throw new Error("No decks found in MAIN. Check your header row and data.");

        // default selection: all on
        selectedDecks = new Set(Object.keys(decks));

        // --- Load Suggestions Tabs ---
        suggestions = {};
        for (const deckName of Object.keys(decks)) {
          const url = CSV_URLS[deckName];
          if (!url) continue; // no matching suggestions tab

          let text;
          try {
            text = await fetchCsv(url);
          } catch {
            continue; // don't fail whole app if one tab isn't published
          }

          const rows = parseCSV(text);
          if (rows.length < 2) continue;

          const map = new Map();
          for (const r of rows.slice(1)) {
            const key = normalizeKey(r[0]);
            if (!key) continue;

            const rest = r.slice(1).map(x => (x ?? "").trim()).filter(Boolean);

            // If they used one "Suggestions" cell, split it; else treat each column as a suggestion.
            let sugg = [];
            if (rest.length === 1) sugg = splitSuggestionsCell(rest[0]);
            else sugg = rest.flatMap(cell => splitSuggestionsCell(cell));

            if (sugg.length) map.set(key, sugg);
          }

          if (map.size) suggestions[deckName] = map;
        }

        renderDeckToggles();
        setStatus("Loaded", true);
        document.getElementById("btnDraw").disabled = selectedDecks.size === 0;
      } catch (e) {
        setStatus("Error", false);
        errEl.textContent = e?.message || String(e);
      }
    }

    /***********************
     * 5) UI
     ***********************/
    function renderDeckToggles() {
      const deckList = document.getElementById("deckList");
      deckList.innerHTML = "";

      const ordered = DEFAULT_DECK_ORDER
        .filter(d => decks[d])
        .concat(Object.keys(decks).filter(d => !DEFAULT_DECK_ORDER.includes(d)));

      for (const deckName of ordered) {
        const count = decks[deckName]?.length ?? 0;

        const label = document.createElement("label");
        label.className = "deck";

        const left = document.createElement("div");
        const title = document.createElement("div");
        title.style.fontWeight = "700";
        title.style.fontSize = "13px";
        title.textContent = deckName;

        const sub = document.createElement("div");
        sub.className = "tiny";
        sub.textContent = `${count} cards`;

        left.appendChild(title);
        left.appendChild(sub);

        const right = document.createElement("div");
        right.className = "row";

        const pill = document.createElement("span");
        pill.className = "pill";
        pill.textContent = suggestions[deckName] ? "has suggestions" : "no suggestions";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = selectedDecks.has(deckName);
        cb.addEventListener("change", () => {
          if (cb.checked) selectedDecks.add(deckName);
          else selectedDecks.delete(deckName);
          document.getElementById("btnDraw").disabled = selectedDecks.size === 0;
        });

        right.appendChild(pill);
        right.appendChild(cb);

        label.appendChild(left);
        label.appendChild(right);
        deckList.appendChild(label);
      }
    }

    function draw() {
      const resultsEl = document.getElementById("results");
      resultsEl.innerHTML = "";

      // draw in default order first
      for (const deckName of DEFAULT_DECK_ORDER.filter(d => selectedDecks.has(d))) {
        resultsEl.appendChild(makeDrawnBox(deckName));
      }
      // then any extras
      for (const deckName of Object.keys(decks).filter(d => selectedDecks.has(d) && !DEFAULT_DECK_ORDER.includes(d))) {
        resultsEl.appendChild(makeDrawnBox(deckName));
      }
    }

    function makeDrawnBox(deckName) {
      const cards = decks[deckName] || [];
      const cardName = sample(cards);

      const box = document.createElement("div");
      box.className = "card";
      box.style.background = "rgba(255,255,255,.03)";
      box.style.borderColor = "rgba(255,255,255,.10)";

      const top = document.createElement("div");
      top.className = "row";
      top.style.justifyContent = "space-between";

      const label = document.createElement("div");
      label.className = "muted";
      label.textContent = deckName;

      const reroll = document.createElement("button");
      reroll.className = "btn secondary";
      reroll.textContent = "Reroll";
      reroll.style.padding = "7px 10px";
      reroll.style.borderRadius = "10px";
      reroll.addEventListener("click", () => {
        box.replaceWith(makeDrawnBox(deckName));
      });

      top.appendChild(label);
      top.appendChild(reroll);
      box.appendChild(top);

      const drawn = document.createElement("div");
      drawn.className = "drawn";
      drawn.textContent = cardName;
      box.appendChild(drawn);

      const suggList = suggestions[deckName]?.get(cardName) || [];
      if (suggList.length) {
        const ul = document.createElement("ul");
        for (const s of suggList) {
          const li = document.createElement("li");
          li.textContent = s;
          ul.appendChild(li);
        }
        box.appendChild(ul);
      } else {
        const none = document.createElement("div");
        none.className = "tiny";
        none.style.marginTop = "8px";
        none.textContent = "No suggestions found for this card.";
        box.appendChild(none);
      }

      return box;
    }

    /***********************
     * 6) EVENTS
     ***********************/
    document.getElementById("btnReload").addEventListener("click", loadAll);
    document.getElementById("btnDraw").addEventListener("click", draw);

    document.getElementById("btnSelectAll").addEventListener("click", () => {
      selectedDecks = new Set(Object.keys(decks));
      renderDeckToggles();
      document.getElementById("btnDraw").disabled = selectedDecks.size === 0;
    });

    document.getElementById("btnSelectNone").addEventListener("click", () => {
      selectedDecks = new Set();
      renderDeckToggles();
      document.getElementById("btnDraw").disabled = true;
    });

    // Initial load
    loadAll();
  </script>
</body>
</html>
