<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Karaoguelike</title>
  <style>
    :root {
      --pad: 16px;
      --purple: #7f5bff;
      --pink: #ff4fd8;
      --aqua: #35f2ff;
      --gold: #ffcf56;
    }
    body {
      font-family: "Trebuchet MS", "Segoe UI", system-ui, sans-serif;
      margin: 0;
      min-height: 100vh;
      background:
        radial-gradient(circle at 10% 10%, rgba(127,91,255,.35), transparent 40%),
        radial-gradient(circle at 90% 20%, rgba(255,79,216,.35), transparent 40%),
        radial-gradient(circle at 30% 80%, rgba(53,242,255,.28), transparent 42%),
        #07070d;
      color:#f4f4f6;
    }
    header {
      padding: 18px var(--pad);
      border-bottom: 1px solid rgba(255,255,255,.08);
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      flex-wrap: wrap;
      position: sticky;
      top: 0;
      background: rgba(7,7,13,.85);
      backdrop-filter: blur(8px);
      z-index: 5;
    }
    h1 { font-size: 18px; margin: 0; font-weight: 750; letter-spacing: .6px; }
    .subtitle { font-size: 12px; color: rgba(255,255,255,.7); }
    .wrap { padding: var(--pad); max-width: 1100px; margin: 0 auto; }
    .card {
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 20px 40px rgba(3,3,8,.35);
    }
    .grid { display:grid; grid-template-columns: minmax(260px, 340px) 1fr; gap: 16px; }
    @media (max-width: 900px){
      .grid { grid-template-columns: 1fr; }
      header { align-items: flex-start; }
    }

    .btn {
      background: linear-gradient(120deg, #fff 0%, #f4f4f6 100%);
      color:#101018;
      border:0;
      padding: 10px 14px;
      border-radius: 999px;
      font-weight: 700;
      cursor:pointer;
      transition: transform .2s ease, box-shadow .2s ease;
      box-shadow: 0 10px 18px rgba(255,255,255,.08);
    }
    .btn.secondary {
      background: rgba(255,255,255,.10);
      color:#fff;
      border: 1px solid rgba(255,255,255,.16);
      box-shadow: none;
    }
    .btn.accent {
      background: linear-gradient(120deg, var(--pink), var(--purple));
      color:#fff;
    }
    .btn.chaos {
      background: linear-gradient(120deg, #ff3b3b, #ff9b36, #b700ff);
      color: #120010;
      text-shadow: 0 0 6px rgba(255,255,255,.35);
      border: 1px solid rgba(255,255,255,.35);
      box-shadow: 0 10px 22px rgba(255, 80, 120, 0.35);
    }
    .btn:disabled { opacity: .55; cursor:not-allowed; transform: none; }
    .btn:hover:not(:disabled) { transform: translateY(-1px) scale(1.01); }

    .row { display:flex; gap: 10px; flex-wrap: wrap; align-items:center; }
    .muted { color: rgba(255,255,255,.75); font-size: 12px; line-height: 1.4; }
    .tiny { color: rgba(255,255,255,.55); font-size: 11px; }

    .decklist { display:flex; flex-direction:column; gap: 10px; margin-top: 12px; }
    .decklist.hidden { display: none; }
    label.deck {
      display:flex;
      justify-content:space-between;
      gap: 10px;
      align-items:center;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      transition: border .2s ease, transform .2s ease;
    }
    label.deck:hover { border-color: rgba(255,255,255,.3); transform: translateY(-1px); }
    label.deck input { transform: scale(1.15); accent-color: var(--pink); }
    label.deck.chaos-deck {
      border-style: dashed;
      border-color: rgba(255,255,255,.45);
      background: linear-gradient(120deg, rgba(255,59,59,.1), rgba(183,0,255,.1));
    }
    .pill {
      font-size: 11px;
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.2);
      color: rgba(255,255,255,.9);
      background: rgba(255,255,255,.08);
    }

    .results { display:flex; flex-direction:column; gap: 12px; }
    .resultTitle { display:flex; align-items:center; justify-content:space-between; gap: 10px; }
    .resultTitle strong { font-size: 14px; }
    .drawn {
      font-size: 22px;
      font-weight: 800;
      margin: 10px 0 0 0;
      letter-spacing: .4px;
      text-shadow: 0 0 18px rgba(53,242,255,.35);
    }
    .kara-card {
      position: relative;
      overflow: hidden;
      border-radius: 18px;
      background:
        linear-gradient(140deg, rgba(255,255,255,.12), rgba(255,255,255,.02)),
        linear-gradient(160deg, rgba(127,91,255,.25), rgba(255,79,216,.2));
      border: 1px solid rgba(255,255,255,.2);
      animation: float 4s ease-in-out infinite;
    }
    .kara-card::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, transparent 20%, rgba(255,255,255,.18) 45%, transparent 70%);
      transform: translateX(-120%);
      animation: shimmer 4s ease-in-out infinite;
      pointer-events: none;
    }
    .idea-list { margin: 10px 0 0 18px; }
    .idea-list li { margin: 6px 0; }
    .idea-btn { margin-top: 10px; }

    .error { color: #ffb3b3; }
    .ok { color: #b7ffcd; }
    .chaos-card {
      background:
        radial-gradient(circle at 20% 20%, rgba(255,59,59,.5), transparent 45%),
        radial-gradient(circle at 80% 30%, rgba(255,155,54,.45), transparent 40%),
        radial-gradient(circle at 50% 80%, rgba(183,0,255,.4), transparent 45%),
        linear-gradient(135deg, rgba(255,255,255,.18), rgba(255,255,255,.04));
      border: 2px dashed rgba(255,255,255,.7);
      box-shadow: 0 0 24px rgba(255, 123, 0, 0.45), 0 0 40px rgba(183, 0, 255, 0.35);
      animation: chaosFloat 3s ease-in-out infinite;
    }
    .chaos-card::after {
      background: linear-gradient(120deg, transparent 10%, rgba(255,255,255,.5) 45%, transparent 80%);
    }
    .chaos-stamp {
      font-size: 10px;
      letter-spacing: .2em;
      text-transform: uppercase;
      color: rgba(255,255,255,.85);
      border: 1px solid rgba(255,255,255,.5);
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(0,0,0,.3);
    }
    .chaos-desc {
      font-size: 13px;
      color: rgba(255,255,255,.85);
      margin-top: 8px;
      line-height: 1.5;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-4px); } }
    @keyframes shimmer { 0%, 100% { transform: translateX(-120%); } 45%, 60% { transform: translateX(120%); } }
    @keyframes chaosFloat { 0%, 100% { transform: translateY(0) rotate(-0.3deg); } 50% { transform: translateY(-6px) rotate(0.6deg); } }

    .hero {
      display:flex;
      flex-direction:column;
      gap: 12px;
    }
    .hero h2 {
      margin: 0;
      font-size: 20px;
      letter-spacing: .3px;
    }
    .hero p { margin: 0; font-size: 13px; color: rgba(255,255,255,.75); }

    .sticky-actions {
      position: sticky;
      bottom: 12px;
      padding-top: 8px;
    }

    .deck-controls {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      margin-top: 14px;
    }

    .deck-actions.hidden {
      display: none;
    }

    @media (max-width: 600px) {
      .row.full-mobile { flex-direction: column; align-items: stretch; }
      .row.full-mobile .btn { width: 100%; justify-content: center; }
      .drawn { font-size: 20px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Karaoguelike</h1>
    <div class="row full-mobile">
      <button class="btn secondary" id="btnReload">Reload data</button>
      <button class="btn accent" id="btnDraw" disabled>Draw a card</button>
      <button class="btn chaos" id="btnChaos" disabled>Draw chaos card</button>
      <button class="btn secondary" id="btnReset">End turn</button>
    </div>
  </header>

  <div class="wrap">
    <div class="grid">
      <div class="card">
        <div class="hero">
          <div class="row" style="justify-content:space-between; align-items:flex-start;">
          <div>
            <h2>Shuffle the karaoke chaos üé§‚ú®</h2>
            <p>Pick your decks, draw one card at a time, and stack extra chaos when you want more spice.</p>
          </div>
            <div id="status" class="pill">Not loaded</div>
          </div>
          <p>Reroll any card until the combo sings, then end the turn so the next performer can customize their own draw.</p>
        </div>

        <div style="margin-top:14px;">
          <div class="deck-controls">
            <div class="muted">Decks in play</div>
            <button class="btn secondary" id="btnToggleDecks" type="button">Hide decks</button>
          </div>
          <div class="decklist" id="deckList"></div>
        </div>

        <div style="margin-top:14px;" class="row deck-actions" id="deckActions">
          <button class="btn secondary" id="btnSelectAll">Select all</button>
          <button class="btn secondary" id="btnSelectNone">Select none</button>
        </div>

        <div style="margin-top:10px;" class="tiny">
          Tip: turn off ‚ÄúSpecific Artist‚Äù if you want more open rounds.
        </div>
        <div style="margin-top:8px;" class="tiny">
          Chaos cards are wild one-time modifiers. Draw them only after you‚Äôve picked your song ‚Äî and they end the turn.
        </div>

        <div id="err" class="tiny error" style="margin-top:10px;"></div>
      </div>

      <div class="card">
        <div class="resultTitle">
          <strong>Draw</strong>
          <span class="tiny">Each draw adds a fresh category. Chaos ends your turn.</span>
        </div>
        <div class="results" id="results" style="margin-top:10px;"></div>
      </div>
    </div>
  </div>

  <script>
    /***********************
     * 1) PUT YOUR PUBLISHED CSV LINKS HERE
     * (these are your links; do not swap to /spreadsheets/d/.../export)
     ***********************/
    const CSV_URLS = {
      "MAIN": "https://docs.google.com/spreadsheets/d/e/2PACX-1vRCJK_-jJKTBYKiYVQz67eXaufFV6z6wxfWY8PFuhPhVp1xOv9dPhJefpJe_RziTvYELRGsHKGRErh6/pub?gid=210868448&single=true&output=csv",
      "Artist Category": "https://docs.google.com/spreadsheets/d/e/2PACX-1vRCJK_-jJKTBYKiYVQz67eXaufFV6z6wxfWY8PFuhPhVp1xOv9dPhJefpJe_RziTvYELRGsHKGRErh6/pub?gid=2134899012&single=true&output=csv",
      "Specific Artist": "https://docs.google.com/spreadsheets/d/e/2PACX-1vRCJK_-jJKTBYKiYVQz67eXaufFV6z6wxfWY8PFuhPhVp1xOv9dPhJefpJe_RziTvYELRGsHKGRErh6/pub?gid=933810467&single=true&output=csv",
      "Era": "https://docs.google.com/spreadsheets/d/e/2PACX-1vRCJK_-jJKTBYKiYVQz67eXaufFV6z6wxfWY8PFuhPhVp1xOv9dPhJefpJe_RziTvYELRGsHKGRErh6/pub?gid=2053657456&single=true&output=csv",
      "Genre": "https://docs.google.com/spreadsheets/d/e/2PACX-1vRCJK_-jJKTBYKiYVQz67eXaufFV6z6wxfWY8PFuhPhVp1xOv9dPhJefpJe_RziTvYELRGsHKGRErh6/pub?gid=308425524&single=true&output=csv",
      "Prompt": "https://docs.google.com/spreadsheets/d/e/2PACX-1vRCJK_-jJKTBYKiYVQz67eXaufFV6z6wxfWY8PFuhPhVp1xOv9dPhJefpJe_RziTvYELRGsHKGRErh6/pub?gid=1185779772&single=true&output=csv",
      "Song Title Rule": "https://docs.google.com/spreadsheets/d/e/2PACX-1vRCJK_-jJKTBYKiYVQz67eXaufFV6z6wxfWY8PFuhPhVp1xOv9dPhJefpJe_RziTvYELRGsHKGRErh6/pub?gid=186500093&single=true&output=csv"
    };

    /***********************
     * 2) HELPERS
     ***********************/
    async function fetchCsv(url) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`Fetch failed (${res.status}). Check that the tab is published as CSV.`);
      return await res.text();
    }

    // Robust CSV parser: handles quoted commas and quoted newlines.
    function parseCSV(text) {
      const rows = [];
      let row = [];
      let cur = "";
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        const next = text[i + 1];

        if (ch === '"' && inQuotes && next === '"') { cur += '"'; i++; continue; }
        if (ch === '"') { inQuotes = !inQuotes; continue; }

        if (ch === ',' && !inQuotes) {
          row.push(cur); cur = "";
          continue;
        }

        if ((ch === '\n' || ch === '\r') && !inQuotes) {
          if (ch === '\r' && next === '\n') i++;
          row.push(cur); cur = "";
          // ignore completely empty trailing line
          if (row.some(cell => (cell ?? "").trim() !== "")) rows.push(row.map(x => (x ?? "").trim()));
          row = [];
          continue;
        }

        cur += ch;
      }

      row.push(cur);
      if (row.some(cell => (cell ?? "").trim() !== "")) rows.push(row.map(x => (x ?? "").trim()));
      return rows;
    }

    function uniq(arr) {
      return [...new Set(arr.filter(Boolean))];
    }

    function sample(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function setStatus(text, ok=true) {
      const el = document.getElementById("status");
      el.textContent = text;
      el.className = "pill" + (ok ? " ok" : "");
    }

    function normalizeKey(s) {
      return (s ?? "").trim();
    }

    function splitSuggestionsCell(s) {
      const raw = (s ?? "").trim();
      if (!raw) return [];
      // split on ; | or line breaks if someone pasted multiple suggestions into one cell
      return raw.split(/[;|]\s*|\r?\n/).map(x => x.trim()).filter(Boolean);
    }

    /***********************
     * 3) APP STATE
     ***********************/
    let decks = {};          // { deckName: [cards...] }
    let suggestions = {};    // { deckName: Map(cardName -> [suggestions...]) }
    let selectedDecks = new Set();
    let chaosCards = [];
    let chaosEnabled = true;
    let drawnDecks = new Set();
    let chaosDrawn = false;
    let decksVisible = true;

    const DEFAULT_DECK_ORDER = ["Artist Category", "Specific Artist", "Era", "Genre", "Prompt", "Song Title Rule"];

    /***********************
     * 4) LOAD DATA
     ***********************/
    async function loadAll() {
      const errEl = document.getElementById("err");
      errEl.textContent = "";
      setStatus("Loading‚Ä¶", true);
      document.getElementById("btnDraw").disabled = true;
      document.getElementById("btnChaos").disabled = true;
      document.getElementById("deckList").innerHTML = "";
      document.getElementById("results").innerHTML = "";

      try {
        if (!CSV_URLS.MAIN) throw new Error("Missing CSV_URLS.MAIN.");

        // --- Load MAIN ---
        const mainText = await fetchCsv(CSV_URLS.MAIN);
        const mainRows = parseCSV(mainText);
        if (mainRows.length < 2) throw new Error("MAIN tab returned no rows. Is it published correctly?");

        const headers = mainRows[0].map(h => (h ?? "").trim());
        const dataRows = mainRows.slice(1);

        decks = {};
        chaosCards = [];
        let chaosTitleIndex = headers.findIndex(h => /chaos/i.test(h));
        let chaosDescIndex = chaosTitleIndex >= 0 ? chaosTitleIndex + 1 : -1;

        if (chaosTitleIndex >= 0) {
          chaosCards = dataRows
            .map(r => ({
              title: (r[chaosTitleIndex] || "").trim(),
              description: (r[chaosDescIndex] || "").trim()
            }))
            .filter(card => card.title);
        }

        headers.forEach((h, idx) => {
          if (!h) return;
          if (idx === chaosTitleIndex || idx === chaosDescIndex) return;
          const colCards = uniq(dataRows.map(r => (r[idx] || "").trim()).filter(Boolean));
          if (colCards.length) decks[h] = colCards;
        });

        if (!Object.keys(decks).length) throw new Error("No decks found in MAIN. Check your header row and data.");

        // default selection: all on
        selectedDecks = new Set(Object.keys(decks));
        chaosEnabled = chaosCards.length > 0;
        drawnDecks = new Set();
        chaosDrawn = false;

        // --- Load Suggestions Tabs ---
        suggestions = {};
        for (const deckName of Object.keys(decks)) {
          const url = CSV_URLS[deckName];
          if (!url) continue; // no matching suggestions tab

          let text;
          try {
            text = await fetchCsv(url);
          } catch {
            continue; // don't fail whole app if one tab isn't published
          }

          const rows = parseCSV(text);
          if (rows.length < 2) continue;

          const map = new Map();
          for (const r of rows.slice(1)) {
            const key = normalizeKey(r[0]);
            if (!key) continue;

            const rest = r.slice(1).map(x => (x ?? "").trim()).filter(Boolean);

            // If they used one "Suggestions" cell, split it; else treat each column as a suggestion.
            let sugg = [];
            if (rest.length === 1) sugg = splitSuggestionsCell(rest[0]);
            else sugg = rest.flatMap(cell => splitSuggestionsCell(cell));

            if (sugg.length) map.set(key, sugg);
          }

          if (map.size) suggestions[deckName] = map;
        }

        renderDeckToggles();
        setStatus("Loaded", true);
        updateActionState();
      } catch (e) {
        setStatus("Error", false);
        errEl.textContent = e?.message || String(e);
      }
    }

    /***********************
     * 5) UI
     ***********************/
    function renderDeckToggles() {
      const deckList = document.getElementById("deckList");
      deckList.innerHTML = "";

      const ordered = DEFAULT_DECK_ORDER
        .filter(d => decks[d])
        .concat(Object.keys(decks).filter(d => !DEFAULT_DECK_ORDER.includes(d)));

      for (const deckName of ordered) {
        const count = decks[deckName]?.length ?? 0;

        const label = document.createElement("label");
        label.className = "deck";

        const left = document.createElement("div");
        const title = document.createElement("div");
        title.style.fontWeight = "700";
        title.style.fontSize = "13px";
        title.textContent = deckName;

        const sub = document.createElement("div");
        sub.className = "tiny";
        sub.textContent = `${count} cards`;

        left.appendChild(title);
        left.appendChild(sub);

        const right = document.createElement("div");
        right.className = "row";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = selectedDecks.has(deckName);
        cb.addEventListener("change", () => {
          if (cb.checked) selectedDecks.add(deckName);
          else selectedDecks.delete(deckName);
          updateActionState();
        });

        right.appendChild(cb);

        label.appendChild(left);
        label.appendChild(right);
        deckList.appendChild(label);
      }

      if (chaosCards.length) {
        const chaosLabel = document.createElement("label");
        chaosLabel.className = "deck chaos-deck";

        const left = document.createElement("div");
        const title = document.createElement("div");
        title.style.fontWeight = "700";
        title.style.fontSize = "13px";
        title.textContent = "Chaos Cards";

        const sub = document.createElement("div");
        sub.className = "tiny";
        sub.textContent = `${chaosCards.length} wild modifiers`;

        left.appendChild(title);
        left.appendChild(sub);

        const right = document.createElement("div");
        right.className = "row";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = chaosEnabled;
        cb.addEventListener("change", () => {
          chaosEnabled = cb.checked;
          updateActionState();
        });

        right.appendChild(cb);
        chaosLabel.appendChild(left);
        chaosLabel.appendChild(right);
        deckList.appendChild(chaosLabel);
      }
    }

    function getRemainingDecks() {
      return Object.keys(decks).filter(d => selectedDecks.has(d) && !drawnDecks.has(d));
    }

    function updateActionState() {
      const btnDraw = document.getElementById("btnDraw");
      const btnChaos = document.getElementById("btnChaos");
      const remainingDecks = getRemainingDecks();

      btnDraw.disabled = chaosDrawn || remainingDecks.length === 0;
      btnChaos.disabled = chaosDrawn || !chaosEnabled || chaosCards.length === 0 || drawnDecks.size === 0;
    }

    function updateDeckVisibility() {
      const deckList = document.getElementById("deckList");
      const deckActions = document.getElementById("deckActions");
      const toggleBtn = document.getElementById("btnToggleDecks");

      deckList.classList.toggle("hidden", !decksVisible);
      deckActions.classList.toggle("hidden", !decksVisible);
      toggleBtn.textContent = decksVisible ? "Hide decks" : "Show decks";
      toggleBtn.setAttribute("aria-expanded", decksVisible ? "true" : "false");
    }

    function drawCard() {
      const resultsEl = document.getElementById("results");

      const availableDecks = getRemainingDecks();
      if (!availableDecks.length) return;

      const deckName = sample(availableDecks);
      drawnDecks.add(deckName);
      resultsEl.appendChild(makeDrawnBox(deckName));
      updateActionState();
    }

    function drawChaosCard() {
      if (!chaosEnabled || chaosDrawn || chaosCards.length === 0 || drawnDecks.size === 0) return;
      const resultsEl = document.getElementById("results");
      const card = sample(chaosCards);
      resultsEl.appendChild(makeChaosBox(card));
      chaosDrawn = true;
      updateActionState();
    }

    function makeDrawnBox(deckName) {
      const cards = decks[deckName] || [];
      const cardName = sample(cards);

      const box = document.createElement("div");
      box.className = "card kara-card";

      const top = document.createElement("div");
      top.className = "row";
      top.style.justifyContent = "space-between";

      const label = document.createElement("div");
      label.className = "muted";
      label.textContent = deckName;

      const reroll = document.createElement("button");
      reroll.className = "btn secondary";
      reroll.textContent = "Reroll";
      reroll.style.padding = "7px 10px";
      reroll.style.borderRadius = "10px";
      reroll.addEventListener("click", () => {
        box.replaceWith(makeDrawnBox(deckName));
      });

      top.appendChild(label);
      top.appendChild(reroll);
      box.appendChild(top);

      const drawn = document.createElement("div");
      drawn.className = "drawn";
      drawn.textContent = cardName;
      box.appendChild(drawn);

      const suggList = suggestions[deckName]?.get(cardName) || [];
      if (suggList.length) {
        const ideaBtn = document.createElement("button");
        ideaBtn.className = "btn secondary idea-btn";
        ideaBtn.textContent = "Need ideas? Click here!";

        const ul = document.createElement("ul");
        ul.className = "idea-list";
        ul.hidden = true;

        for (const s of suggList) {
          const li = document.createElement("li");
          li.textContent = s;
          ul.appendChild(li);
        }

        ideaBtn.addEventListener("click", () => {
          ul.hidden = !ul.hidden;
          ideaBtn.textContent = ul.hidden ? "Need ideas? Click here!" : "Hide ideas";
        });

        box.appendChild(ideaBtn);
        box.appendChild(ul);
      }

      return box;
    }

    function makeChaosBox(card) {
      const box = document.createElement("div");
      box.className = "card chaos-card";

      const top = document.createElement("div");
      top.className = "row";
      top.style.justifyContent = "space-between";

      const label = document.createElement("div");
      label.className = "muted";
      label.textContent = "Chaos Modifier";

      const stamp = document.createElement("div");
      stamp.className = "chaos-stamp";
      stamp.textContent = "CHAOS";

      top.appendChild(label);
      top.appendChild(stamp);
      box.appendChild(top);

      const drawn = document.createElement("div");
      drawn.className = "drawn";
      drawn.textContent = card.title;
      box.appendChild(drawn);

      if (card.description) {
        const desc = document.createElement("div");
        desc.className = "chaos-desc";
        desc.textContent = card.description;
        box.appendChild(desc);
      }

      return box;
    }

    /***********************
     * 6) EVENTS
     ***********************/
    document.getElementById("btnReload").addEventListener("click", loadAll);
    document.getElementById("btnDraw").addEventListener("click", () => drawCard());
    document.getElementById("btnChaos").addEventListener("click", () => drawChaosCard());
    document.getElementById("btnReset").addEventListener("click", () => {
      document.getElementById("results").innerHTML = "";
      drawnDecks = new Set();
      chaosDrawn = false;
      updateActionState();
      window.scrollTo({ top: 0, behavior: "smooth" });
    });

    document.getElementById("btnSelectAll").addEventListener("click", () => {
      selectedDecks = new Set(Object.keys(decks));
      renderDeckToggles();
      updateActionState();
    });

    document.getElementById("btnSelectNone").addEventListener("click", () => {
      selectedDecks = new Set();
      renderDeckToggles();
      updateActionState();
    });

    document.getElementById("btnToggleDecks").addEventListener("click", () => {
      decksVisible = !decksVisible;
      updateDeckVisibility();
    });

    // Initial load
    loadAll();
    updateDeckVisibility();
  </script>
</body>
</html>
